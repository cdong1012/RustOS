Scene1 What's up guys? It's Peter from group 21. This is my demo about what I have so far for 
the final project. I'm currently working on an ELF parser for our operating system in order to be able to execute elf files.


Scene2(From last slide): From the last presentation, I was going to implement ASLR or address space layout randomization as 
the main theme of this project. However, I changed my mind midway through project 4 because 
dealing with virtual memories has been horrible.

Scene3 So I came to our TA, Mansour, for ideas, and he suggested writing an ELF parser. The main reasonis that we are only 
loading and executing the .bin file into virtual memory for lab 4. 
Nowadays in a real life OS, we usually won't be working with .bin file much.
It's a standard for linux to execute ELF files, and that's why our operating system should do the same.

Scene 3.5(memes, boy look back at ELF while going with bin):  I thought that it would be a cool idea since 
I wanted to learn how ELF works too, and here we are. 

Scene 4: So if you are like me when I first approached this idea, you're probably wondering "What's in the ELF file? and 
how can we execute it?". 

Scene 6(wiki): Then, I just looked it up on Wikipedia. Elf stands for Executable and Linkable Format, and I'm going to try and 
explain this file type according to what I've learned so far.

Scene 7(THu elf): Ok, so, an ELF file is divided into different components, but most important is the file header, the header table, 
and the section table.

Scene 8( Thu file header): The file header is the very first 64 bits, which store information such as if this file is 64 bits or 
32 bits format, little or big endian, target OS type, and so on. But the most important info here is the offset of the 
header table and section table helping us locate these next two structure. 

Scene 9(show code header): So I get started parsing. As you can see, it was really similar to what we did for the file system,
I created a struct for the filer header, read the raw bytes in, manually translate bytes into u8, u16, u32, and u64.
I could have used transmute, but I prefer not to use unsafe code.

Scene 10(THu header table): From the file header, we know the offset of the header table from the begining of the file.
So header table is the spiciest part of ELF in my opinion. This table's entries store information helping the OS 
to construct the process image. The most important things in here are the offset and size of the segment in this file image. 

Scene 11( Thu offset ): Let's say the segment is our binary code. The offset can be something ike 10000 and the code size is 
6900. We can use this information from the header table's entry to read them into a byte array, and map it into the virtual 
space in our process.rs. The file header already specifies where in virtual memory we need to load this image in, so after we 
load this segment there, we can hopefully execute it.

Scene 12(demo readelf): On the way of implementing the parser,
I used some linux commands to help me check my parsing, so I thought it would be fun to 
implement them too for our RustOS. Readelf -h on linux gives us info about the file header, 
and this is what I have on my OS when I run my own parser. When I have time after this week, I'm intergrating this feature 
into our shell, so we can execute readelf just like on linux.

Scene 13(demo load process): So, to demo that I actually can execute ELF files on my OS, I created a new load function in process.rs
to load the elf file, Parse it and put the binary into virtual memory according. After that, I just let it run like phase 4 of 
our last project.

Scene 13.5; as you can see, the elf files execute normally just like when we load the bin fib in our project 4. At this point, 
we can execute any elf file generated without dynamic linking.

Scene 14(Thu aslr): Now that I got the parser working, I'm looking into implement ASLR for our current OS. ASLR is address space 
layout randomization, basically throwing our process page and stack page around on the virtual address space in a random manner 
everytime we boot.

Scene 15(demo random): So how do I get something random? Well, we already got the timer working, so I can use the current
time after the OS is done initializing allocator, file system, IRQ handler, and MMU as my random seed. 
This time is random through boots, and we can check it just through a quick kprintln. 
As you can see, this number is randomly different everytime we run, so it can be a good seed to generate random number 

Scene 16( random): We can use modulo arithmetic to get our random number when implement RndCore for our random number generator.
        // Xn+1 = (aXn + c) mod m
        // where X is the sequence of pseudo-random values
        // m, 0 < m  - modulus 
        // a, 0 < a < m  - multiplier
        // c, 0 ≤ c < m  - increment
        // x0, 0 ≤ x0 < m  - the seed or start value

I haven't fully implement ASLR yet, but I'm hoping to get a randomize index for each process, put the code segment 
Pagesize*index away from USER_IMG_BASE, and do the same thing for stack. This only works because our fib code is small, and it 
can all fit into 1 page. For longer files without PIC, or position independent code, it will be hard to ensure execution 
after we randomly move the code segment. This is all that I have done for the final project after being done with Lab 4.
I really appreciate you guys watching this and if you like it, please give it a like, comment, or subscribe. Thank you 
